# 12월 12일 최댓값, 최솟값, 대푯값 산출

#수치 데이터를 분석할때 보통 평균값을 이용한다. 서로 다른 데이터 집합을 
#비교할때 같은 열의 수치 데이터의 평균값을 비교하는 것은 분석의 기본이다.

#평균은 원리가 단순하고 쉬워 수치 데이터의 특징을 나타내는 데 유용하다.
#하지만 데이터 분포를 파악하지 않고 평균값의 결과만을 그대로 받아들이면
#결과를 잘못 인식할 수 있다.

#평균값이 같아도 데이터 분포가 다르면 데이터 특성은 크게 달라진다.
#평균값만드로는 데이터 특징을 표현하기 어려우므로 평균값 외에도
#최댓값, 최솟값, 대푯값(중앙값, 백분위수) 또는 표준편차 등을 알아둬야 한다.

#평균값은 중앙값이나 백분위수에 비해 계산 비용이 적어 우수하다.
#모든 데이터의 합을 데이터 수로 나누어 계산하며 병렬처리가 가능하고 
#데이터를 읽을 때마다 합곗값과 데이터 수를 갱신하면 되므로 필요한
#메모리도 적다.

#그리고 중앙값이나 백분위수를 계산하려면 어느 정도의 데이터를 값에 따라
#재정렬하고 파악해둬야 하는데, 이 과정은 메모리와 계산 시간이 많이 소모된다.
#데이터 수가 많을때는 중앙값이나 백분위수를 계산하기 어렵다는 점을 기억하자

#대푯값!
#대상 데이터셋은 호텔 예약 레코드이다. 예약 테이블에서 호텔별 예약 금액의
#최댓값, 최솟값, 평균값, 중앙값, 20백분위 값(근사값도 가능)을 산출해보자.

reserve_tb <- read.csv("reserve.csv", header = T, fileEncoding = 'utf-8',
                       stringsAsFactors = F)

reserve_tb %>% 
  group_by(hotel_id) %>% #호텔별로 예약금액의 통계량을 알고 싶으니까 group_by
  
  #quantile 함수에 total_price와 대상 값을 지정하여 20% 백분위 값을 산출한다
  summarise(price_max = max(total_price),
            price_min = min(total_price),
            prive_avg = mean(total_price),
            price_median = median(total_price),
            price_20per = quantile(total_price, 0.2))
#quantile 함수는 보통 25% 단위로 값을 반환하지만 두 번째 매개변수에 값을
#지정하여 원하는 백분위를 얻을 수 있다. reserve_tb %>% summary()와 같이
#summary함수를 호출하면 평균값, 분산값, 4분위(25%의 백분위값) 등
#대푯값을 자동으로 계산하여 출력한다. 데이터의 전체적인 경향을 파악하는데
#유용하다.

#집약 처리를 한꺼번에 실행하여 가독성이 좋고 효율적으로 처리하는 Awesome한
#코드이다.
  

#3.4 분포 계산

#분산값과 표준편차값은 데이터의 분포 정도를 나타낸다.
#대푯값과 함께 이용하면 수치 데이터의 전체적인 경향을 더욱 잘 표현할 수 있다.

#분산값을 이욯할때 한 가지 주의할 점이 있다. 분산값과 표준편찻값의 계산식에는
#''데이터 수-1'' 값을 이용해 나누는 부분이 있는데 이때 데이터 수가 1이면
#0으로 나누어 잘못된 값이 나온다. 따라서 데이터 수가 1일 때는 다르게 처리
#해야 한다. 보통 데이터 수가 1일때는 데이터의 분포가 전혀 없다는 뜻이므로
#분산값과 표준편찻값 모두 0으로 처리하자! 분산값과 표준편차값은 데이터 분포를
#알 수 있는 기본적인 지표지만, 데이터 분석의 기초 집계 작업에서 전혀 확인하지
#않는 경우가 간혹 있는데 항상 분산값과 표준편차값을 생각하는 습관을 들이자!

#데이터 셋은 호텔 예약 레코드를 사용한다.
#예약테이블에서 각 호텔 예약 금액의 분산 값과 표준편차값을 구해보자
#다만 예약이 한 건뿐이라면 분산값과 표준편차값을 0으로 한다.

reserve_tb %>% 
  group_by(hotel_id) %>% 
  
  #var함수에 total_price를 지정하여 분산값을 계산한다.
  #sd함수에 total_price를 지정하여 표준편차값을 계산한다.
  #데이터 수가 한 건이면 NA이므로, 
  #coalesce 함수를 이용하여 NA이면 0으로 치환한다.
  summarise(price_var = coalesce(var(total_price), 0),
            price_sd = coalesce(sd(total_price), 0))

#var함수로 분산을, sd함수로 표준편차를 계산한다. 데이터 수가 한건이면 
#분산값과 표준편차값이 NA가 되는데 이것을 피하고자 coalesce 함수를 이용하여
#0으로 변환한다. coalesce 함수는 매개변수에 지정된 값 중 NULL이 아닌 값을
#반환하는 함수로, 매개변수에 지정된 순서가 앞일수록 우선순위가 높다.
#또한 replace_na 함수를 사용하여 분산값과 표준편찻값을 계산한 후 
#replace_na(list(price_var=0, price_std=0))와 같은 형식으로 작성할 수도 있다.

#replace_na함수를 NA를 변경할 열 이름과 변경할 값을 조합한 리스트를
#매개변수로 전달하여 NA를 지정한 값으로 변환할 수 있다. 이외에도
#result[is.na(result)] <- 0 과 같은 작성방법도 있다. 이 코드는
#NA인 값을 모두 호출하여 0으로 변환하는 코드이다. 단, 상관없는 NA값도
#모두 0으로 변환할 수 있기 때문에 조심해야 한다.

#dplyr을 활용하여 간단하게 집약처리를 구현했으며 처리하기 까다로운
#데이터 수에 따른 값의 변경은 coalesce함수로 구현한다. 상황에 따라
#적절한 라이브러리를 사용한 AWESOME한 코드이다!