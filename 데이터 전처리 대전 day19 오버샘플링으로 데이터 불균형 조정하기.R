#12월 30일 6.2 오버샘플링으로 데이터 불균형 조정하기

#오버샘플링은 원본 데이터에서 새로운 데이터를 생성한다. 생성 방법 중 하나는
#랜덤샘플링으로 원래 데이터 수보다 많은 데이터를 추출하는 것이다. 매우
#간단하지만 완전히 똑같은 데이터가 생성되기 때문에 과학습이 발생할 수 있다.
#이러한 문제를 해결한 대표적인 오버샘플링 기법으로 SMOTE가 있다. SMOTE는
#오버샘플링을 할 때 원본 데이터를 기반으로 새로운 데이터를 생성하는 방법이다.
#SMOTE의 데이터 생성 부분 알고리즘 개요는 다음과 같다.

#1. 원본 데이터에서랜덤하게 하나의 데이터를 선택한다.
#2. K값을 설정하여 1~K의 정숫값에서(균일분포) 랜덤하게 n을 설정한다.
#3. 1에서 서택한 데이터에서 n번째로 가까운 데이터를 새롭게 선택한다.
#4. 1과 3에서 선택한 데이터를 기반으로 새로운 데이터를 생성한다.
#[생성할 데이터의 값] = [1에서 선택한 값]+([3에서 선택한 값]-[1에서 선택한 값]*[0부터 1사이의 균일 분포 난수]
#5. 지정한 데이터 수에 도달할 때까지 1~4를 반복한다.

#SMOTE로 생성된 데이터는 원본 데이터와 같은 특성을 유지하면서 약간의 노이즈를
#더한 데이터를 의미한다. 그 결과 단순한 랜덤 샘플링으로 원본 데이터를 복사하는 것
#보다 좀 더 자연스럽게 발생한 데이터에 가까운 값을 가진다. 따라서 모델의 정확도가
#높아질 수 있어 단순히 원본 데이터를 복사하는 오버샘플링보다 SMOTE를 사용하는
#편이 좋다.

#다만 SMOTE도 완벽한 것은 아니다. SMOTE는 샘플링 원본 데이터끼리의 직선상 값을
#샘플링하는 방법이다. #차원수(생성할 데이터의 열 수)가 큰 경우에는
#큰 공간이 존재하는 것에 비해 샘플링 원본 데이터 사이의 직선상에만 샘플링하게
#되어 편중된 샘플링이 되기 쉽다. 차원 수가 큰 경우에는 언더샘플링과
#배깅을 조합하여 예측 모델을 구축하는 편이 안정적이다.

#배깅이란 다수의 모델을 독립적으로 만들어, 다수의 모델의 예측 결과를 이용하여
#마지막에 예측 값을 계싼하는 기법이다. 모델 별로 전체 데이터의 일부를
#이용하여 학습하자. 랜덤 포레스트 등의 머신러닝 기법이 이에 해당한다.

#Q1. 데이터셋은 제조 레코드를 사용한다. 장애가 발생하지 않은 레코드
#(fault_flg가 False)레코드가 927건, 장애가 발생한 레코드(fault_flg가 True)가
#73건 있다. 장애가 발생할 레코드를 SMOTE로 오버샘플링하여 장애가 발생하지
#않은 레코드의 건수에 가깝게 만들자 SMOTE의 K매개변수는 5로 하자

#R
#R에서는 SMOTE를 이용할 수 있는 패키지가 제공되지만 제약이 있다.
#중복을 허용하는 랜덤 언더샘플링과 SMOTE를 사용하는 오버샘플링이 하나로
#묶였다는 것이다. 편리하지만 이용 방법이 복잡하므로 이 함수 SMOTE의
#오버샘플링만을 사용하는 방법으로 코드를 설명한다.

#ubBalance를 위한 라이브러리
install.packages("unbalanced")
library(unbalanced)
library(tidyverse)

#perc0ver의 설정값을 계산한다. 
t_num <- production_tb %>% filter(fault_flg == T) %>% summarise(t_num=n())
f_num <- production_tb %>% filter(fault_flg == F) %>% summarise(f_num=n())
perc0ver <- round(f_num / t_num) * 100 - 100

#불균형을 고칠 대상을 factor형으로 변환한다. (logical형이 아닌 것에 주의)
#(9장에서 설명한다.)
production_tb$fault_flg <- as.factor(production_tb$fault_flg)

#unBalance 함수로 오버샘플링을 구현한다.
#type에 ubSMOTE를 설정한다.
#positive에는 적은 쪽의 값을 지정한다.(지정하지 않을 수도 있지만 경고가 표시됨)
#perc0ver는 원본 데이터에서 몇 % 늘릴지 설정한다.
#(200이면 3(200/100+1)배, 500이면 6(500/100+1)배가 된다. 100미만의 값은
#버림으로 처리된다.)
#percUnder는 언더샘플링을 실행할 때 필요하지만 실행하지 않을 경우에는 0을
#설정한다.

#k는 smote의 k매개변수
production_balance <-
  ubBalance(production_tb[, c('length', 'thickness')],
            production_tb$fault_flg,
            type = 'ubSMOTE', positive = 'TRUE',
            percOver = percOver, percUnder = 0, k = 5)

#생성한 fault_flg가 TRUE인 데이터와 원본의 fault_flg가 FALSE인 데이터를 합친다.
bind_rows(
  #production_balance$X에 생성한 length와 thickness의 data.frame이 저장된다.
  production_balance$X %>% 
    #production_balance$Y에 생성한 fault_flg의 벡터가 저장된다.
    mutate(fault_flg = production_balance$Y),
  
  #원본의 fault_flg가 False인 데이터를 구한다.
  production_tb %>% 
    
    #factor형이기 때문에 일치 여부를 만족하는 값을 구한다.
    filter(fault_flg == 'FALSE') %>% 
    select(length, thickness, fault_flg)

#ubBalance 함수로 SMOTE를 구현할 때는 첫번째 매개변수에 오버샘플링할 대상열을
#지정하고, 두번째 매개변수에 분류 결과를 지정하자. 분류 결과는 범주형이어야한다.
#범주형은 9장에서 자세히 설명한다. 이 예제는 수치값만 처리하지만,
#ubBalnce 함수의 SMOTE는 범줏값도 오버샘플링의 대상으로 할 수 있다.
#대상으로 추가한 경우 첫 번째 매개변수에 추가하면 된다. 범줏값을 생성하는
#알고리즘은 SMOTE로 선택된 두 개의 원본 데이터 범줏값에서 랜덤하게
#한쪽의 범줏값을 사용하는 식의 알고리즘이다.

#percUnder에 0이외의 값을 설정하면 불균형 데이터 중 많은 쪽의 열 데이터를
#샘플링하여 추출한다. 이때 중복을 허용하는 랜덤 샘플링으로 실행되어
#중복데이터가 발생한다. 또한 랜덤샘플링할때 데이터양을 perUnder값으로
#제어하기 위해서는 매우 복잡한 사용법을 이해해야한다. percUnder값을 0으로 하여
#불균형 데이터의 양이 많은 쪽의 데이터를 반환하지 않도록 SMOTE의 오버샘플링이
#실행되는 방식으로 사용하자

#다소 융통성이 없는 함수이지만 직접 구현하지 않고 SMOTE의 오버샘플링 부분만을
#이용한다. 유명하지 않은 전처리 라이브러리는 패키지에 따라 사양의 차이가 있고
#충분한 문서도 제공되지 않는 경우가 많기 때문에 제공되는 패키지의 내용을
#정확히 인지해야 한다. 패키지의 내용을 잘 확인한 AWESOME한 코드다.