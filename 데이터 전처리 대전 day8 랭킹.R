#12월 15일 랭킹

#데이터 셋은 호텔 예약 레코드를 사용한다. 예약 테이블을 이용하여
#호텔별 예약 건수에 따른 순위를 매겨본다. 예약 건수가 같으면 예약 건수가 같은
#모든 호텔에 최소 순위를 매긴다. (공동으로 순위를 매기겠다는 소리)

#이 예제는 dplyr 패키지의 파이프연산자로 연결하여 처리하는 것의 훌륭함을
#알 수 있다. 파이프연산자를 활용하여 매끄러운 코드를 만들어보자

reserve_tb %>% 
  #hotel_id를 집약 단위로 지정하여 호텔별 예약 건수를 계산한다.
  group_by(hotel_id) %>% 
  
  #데이터 건수를 계산하여 호텔별 예약 횟수를 계산한다.
  summarise(rsv_cnt = n()) %>% 
  #예약 횟수를 기준으로 순위를 계산, desc 함수를 이용해 내림차순으로 정렬한다.
  #transmute 함수로 rsv_cnt_rank를 생성하여,
  #필요한 hotel_id와 rsv_cnt_rank만을 추출한다.
  transmute(hotel_id, rsv_cnt_rank = min_rank(desc(rsv_cnt)))

#transmute 함수는 mutate함수와 마찬가지로 새로운 열을 추가할 수 있지만,
#지정한 열만을 남긴다. 즉 mutate함수와 select가 합쳐진 기능을 가진다.

#min_rank 함수 등 순위를 계산할때 순서를 내림차순으로 변경하려면 정렬시에
#참조하는 열에 desc함수를 적용한다.

#이 코드는 파이프라인을 활용하여 데이터를 매끄럽게 처리한다. dplyr 패키지의
#파이프라인 처리를 이용하면 연속된 처리를 가독성과 성능 효율이 좋은
#코드를 작성할 수 있다. 보기에도 깔끔한 awesome한 코드이다.
